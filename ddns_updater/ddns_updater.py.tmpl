#encoding utf-8
\#!/usr/bin/python
\# -*- coding: utf-8 -*-

#raw
################################################################################
# DO NOT MODIFY THIS FILE.                                                     #
# It is generated by the template named like this file and a .tmpl suffix      #
# added. Make modifications to the template and regenerate this file.          #
################################################################################
#end raw

\#    This program is free software: you can redistribute it and/or modify
\#    it under the terms of the GNU General Public License as published by
\#    the Free Software Foundation, either version 3 of the License, or
\#    (at your option) any later version.
#echo '#\n'
\#    This program is distributed in the hope that it will be useful,
\#    but WITHOUT ANY WARRANTY; without even the implied warranty of
\#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
\#    GNU General Public License for more details.
#echo '#\n'
\#    You should have received a copy of the GNU General Public License
\#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#echo '#'
\#    Dieses Programm ist Freie Software: Sie können es unter den Bedingungen
\#    der GNU General Public License, wie von der Free Software Foundation,
\#    Version 3 der Lizenz oder (nach Ihrer Wahl) jeder neueren
\#    veröffentlichten Version, weiterverbreiten und/oder modifizieren.
#echo '#\n'
\#    Dieses Programm wird in der Hoffnung, dass es nützlich sein wird, aber
\#    OHNE JEDE GEWÄHRLEISTUNG, bereitgestellt; sogar ohne die implizite
\#    Gewährleistung der MARKTFÄHIGKEIT oder EIGNUNG FÜR EINEN BESTIMMTEN ZWECK.
\#    Siehe die GNU General Public License für weitere Details.
#echo '#\n'
\#    Sie sollten eine Kopie der GNU General Public License zusammen mit diesem
\#    Programm erhalten haben. Wenn nicht, siehe <http://www.gnu.org/licenses/>.

\# There's currently no option to omit logging to file.
#echo '#\n'
\# Multiple invokations in a short range of time can cause the DDNS service
\# (strato) to reject further update requests for a certain time. This is a
\# mechanism by strato to prevent abuse. The caller is responsible to deal with
\# this or use the built-in functions controlled by the settings
\# `check_interval`, `loop` and `daemon`.
#echo '#\n'
\# There's currently no support for configuration files because plac doesn't
\# allow to check which function arguments have been specified on the command
\# line and which are taken from default values, asked http://stackoverflow.com/questions/32302037/how-to-figure-out-which-command-line-parameters-have-been-set-in-plac for inputs.

import plac
import urllib2
import base64
import logging
import time
import os
import strato_ddns_updater_globals
import importlib
import subprocess as sp
import sys
import socket

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger_stdout_handler = logging.StreamHandler()
logger_stdout_handler.setLevel(logging.INFO)
logger_formatter = logging.Formatter('%(asctime)s:%(message)s')
logger_stdout_handler.setFormatter(logger_formatter)
logger.addHandler(logger_stdout_handler)

check_file_path_default = "/tmp/strato-ddns-updater.dat"
check_interval_default_ipecho = 60*15
check_interval_default_dig = 30
check_interval_default = None
daemon_default=False
loop_default = False
log_dir_default = "$log_file_dir_path"
debug_default = False

ip_service_ipecho = "ipecho"
ip_service_dig = "dig"
ip_service_default = ip_service_dig

# binaries
systemctl = "systemctl"
modprobe = "modprobe"
ip = "ip"
ifconfig = "ifconfig"
iptables = "iptables"

__ip_service_docstring__ = "Whether to use DNS name resolution or an external IP echo service to detect changes to DDNS IP. The choice impacts the shortness of intervals (DNS queries can performed more frequently than IP echo service queries because you get blocked for the latter if requests are sent too often) and the possibility to have a LAN (you might want to resolve a server name to a LAN IP inside the LAN rather than its WAN IP, i.e. you need an IP echo service)"
__dig_hostname_docstring__ = "The hostname to pass to the dig command"

class DDNSUpdaterCommandParser(object):
    commands = "strato", "openafs"

    def __init__(self):
        super(DDNSUpdaterCommandParser, self).__init__()

    @plac.annotations(hostname=("The DDNS hostname to be updated", "positional"),
        username=("The strato username", "positional"),
        password=("The strato DDNS password", "positional"),
        no_mx=("Setting MX entry is skipped if flag is set", "flag"),
        base_url=("Overwrite the base URL of the strato service", "option"),
        check_file_path=("Path to the file where the result of the last IP check is stored", "option"),
        check_interval=("The time in seconds between two checks of the current external IP (this is time your DDNS isn't reachable in the worst case) (don't set this value too low because the service to check for external IP (currently ipecho.net) might block you if you send too many requests) (None indicates that a default for the IP service ought to be chosen)", "option"),
        loop=("Run as a loop with check_interval between runs (uses check_file to minimize requests to IP echo service)", "flag"),
        daemon=("Run as daemon (implies loop)", "flag"),
        log_dir=("The directory where to create log files (will be created if it doesn't exist) (expects permissions for creation and writing to be given)", "option"),
        debug=("Log debug information", "flag"),
        ip_service=(__ip_service_docstring__, "option"),
        dig_hostname=(__dig_hostname_docstring__, "option"))
    def strato(self,
        hostname=None,
        username=None,
        password=None,
        no_mx=False,
        base_url="https://dyndns.strato.com/nic/update",
        check_file_path=check_file_path_default,
        check_interval=check_interval_default,
        loop=loop_default,
        daemon=daemon_default,
        log_dir=log_dir_default,
        debug=debug_default,
        ip_service=ip_service_default,
        dig_hostname=None
    ):
        if hostname is None or username is None or password is None:
            # importing configuration file values
            config_dir_name = "strato-ddns-updater"
            config_dir_path = os.path.join("/etc", config_dir_name)
            if not os.path.exists(config_dir_path):
                logger.info("creating inexisting configuration directory '%s'" % (config_dir_path,))
            sys.path.append(config_dir_path)
            config_module_name = "config"
            config_file_name = "%s.py" % (config_module_name,)
            config_file_path = os.path.join(config_dir_path, config_file_name)
            if os.path.exists(config_file_path):
                config = importlib.import_module(config_module_name)
            if hostname is None:
                hostname = config.hostname
                if hostname is None:
                    raise Error("hostname is neither specified on command line nor in configuration file '%s'" % (config_file_path,))
            if username is None:
                username = config.username
                if username is None:
                    raise Error("username is neither specified on command line nor in configuration file '%s'" % (config_file_path,))
            if password is None:
                password = config.password
                if password is None:
                    raise Error("password is neither specified on command line nor in configuration file '%s'" % (config_file_path,))
        instance = StratoDDNSUpdater(hostname=hostname,
            username=username,
            password=password,
            no_mx=no_mx,
            base_url=base_url,
            check_file_path=check_file_path,
            check_interval=check_interval,
            daemon=daemon,
            loop=loop,
            log_dir=log_dir,
            debug=debug,
            ip_service=ip_service,
            dig_hostname=dig_hostname)
        instance.run()

    @plac.annotations(check_file_path=("Path to the file where the result of the last IP check is stored", "option"),
        check_interval=("The time in seconds between two checks of the current external IP (this is time your DDNS isn't reachable in the worst case) (don't set this value too low because the service to check for external IP (currently ipecho.net) might block you if you send too many requests)", "option"),
        loop=("Run as a loop with check_interval between runs (uses check_file to minimize requests to IP echo service)", "flag"),
        daemon=("Run as daemon (implies loop)", "flag"),
        log_dir=("The directory where to create log files (will be created if it doesn't exist) (expects permissions for creation and writing to be given)", "option"),
        debug=("Log debug information", "flag"),
        ip_service=(__ip_service_docstring__, "option"),
        dig_hostname=(__dig_hostname_docstring__, "option"))
    def openafs(self,
        check_file_path=check_file_path_default,
        check_interval=check_interval_default,
        loop=loop_default,
        daemon=daemon_default,
        log_dir=log_dir_default,
        debug=debug_default,
        ip_service=ip_service_default,
        dig_hostname=None
    ):
        instance = OpenAFSDDNSUpdater(check_file_path=check_file_path,
            check_interval=check_interval,
            daemon=daemon,
            loop=loop,
            log_dir=log_dir,
            debug=debug,
            ip_service=ip_service,
            dig_hostname=dig_hostname)
        instance.run()

class DDNSUpdater(object):

    def __init__(self,
        check_file_path=check_file_path_default,
        check_interval=check_interval_default,
        daemon=daemon_default,
        loop=loop_default,
        log_dir=log_dir_default,
        debug=debug_default,
        ip_service=ip_service_default,
        dig_hostname=None
    ):
        super(DDNSUpdater, self).__init__()
        self.check_file_path = check_file_path
        if check_interval != None:
            self.check_interval = check_interval
        else:
            if ip_service == ip_service_ipecho:
                self.check_interval = check_interval_default_ipecho
            elif ip_service == ip_service_dig:
                self.check_interval = check_interval_default_dig
            else:
                raise ValueError("IP service '%s' isn't supported" % (self.ip_service,))
        logger.debug("using check interval '%s'" % (str(check_interval),))
        self.daemon = daemon
        self.loop = loop
        self.log_dir = log_dir
        self.debug = debug
        self.ip_service = ip_service
        self.dig_hostname = dig_hostname

    def get_log_dir(self):
        return os.path.join(self.log_dir, "%s-ddns-updater" % (self.name,))

    def run(self):
        try:
            check_interval_float = float(self.check_interval)
        except ValueError:
            raise ValueError("check interval '%s' could not be parsed as float" % (str(self.check_interval), ))
        if not os.path.exists(self.get_log_dir()):
            logger.info("creating inexisting log directory '%s'" % (self.get_log_dir(),))
            os.makedirs(self.get_log_dir())
        elif os.path.isfile(self.get_log_dir()):
            raise ValueError("log_dir '%s' is an existing file, but needs to be an existing directory or point to an inexisting path" % (self.get_log_dir(),))

        logger_file_handler = logging.FileHandler(filename=os.path.join(self.get_log_dir(), strato_ddns_updater_globals.log_file_name), mode='a', encoding=None, delay=False)
        logger_file_handler.setFormatter(logger_formatter)
        logger.addHandler(logger_file_handler)
        if self.debug:
            logger.setLevel(logging.DEBUG)
            logger_stdout_handler.setLevel(logging.DEBUG)
            logger_file_handler.setLevel(logging.DEBUG)
        if self.daemon:
            if self.loop is False:
                logger.warn("daemon implies loop")
            self.loop = True
        # clear check file (reusage accross service restarts doesn't make too much sense except for debugging)
        if os.path.exists(self.check_file_path):
            os.remove(self.check_file_path)
        \# @return a time to sleep in seconds
        def __update__(loop=self.loop, check_interval_float=check_interval_float):
            if self.ip_service == ip_service_ipecho:
                echo_url = "http://ipecho.net/plain"
                logger.debug("checking external IP at '%s'" % (echo_url,))
                dyndns_response = urllib2.urlopen(echo_url).readline().strip()
                self.external_ip = dyndns_response
            elif self.ip_service == ip_service_dig:
                if self.dig_hostname is None:
                    raise ValueError("option --dig-hostname needs to be specified if IP service is 'dig'")
                logger.debug("checking external IP with DNS resolution")
                self.external_ip = socket.gethostbyname(self.dig_hostname)
            else:
                raise ValueError("IP service '%s' isn't supported" % (self.ip_service,))
            logger.debug("external IP is '%s'" % (self.external_ip,))
            if loop:
                \# only check last result if loop is True (otherwise there's no last result stored anyway and sleeping doesn't make sense neither)
                logger.debug("storing last check result in file '%s'" % (self.check_file_path,))
                if os.path.exists(self.check_file_path):
                    check_file = open(self.check_file_path)
                    last_external_ip = check_file.readline().strip()
                    check_file.close()
                    if last_external_ip == self.external_ip:
                        logger.debug("result of external IP check is identical to the last result, sleeping check interval (%s s)" % (str(check_interval_float),))
                        time.sleep(check_interval_float)
                        return check_interval_float
                check_file = open(self.check_file_path, "w")
                check_file.write(self.external_ip)
                check_file.flush()
                check_file.close()

            check_iverval_float = self.action()
            return check_interval_float

        def __loop__():
            check_interval_float0 = check_interval_float
            while True:
                check_interval_float0 = __update__(check_interval_float=check_interval_float0)
        if not self.loop:
            __update__()
        else:
            if self.daemon:
                pid = os.fork()
                if pid == 0:
                    __loop__()
                \# don't care about parent
                sys.exit(0)
            else:
                __loop__()

class OpenAFSDDNSUpdater(DDNSUpdater):

    def __init__(self,
        check_file_path,
        check_interval,
        daemon,
        loop,
        log_dir,
        debug,
        ip_service,
        dig_hostname
    ):
        super(OpenAFSDDNSUpdater, self).__init__(check_file_path=check_file_path,
            check_interval=check_interval,
            daemon=daemon,
            loop=loop,
            log_dir=log_dir,
            debug=debug,
            ip_service=ip_service,
            dig_hostname=dig_hostname
        )
        self.name="openafs"
        self.virtual_interface_address = None

    def action(self):
        # Adjust virtual interface to new external IP (following http://unix.stackexchange.com/questions/152331/how-can-i-create-a-virtual-ethernet-interface-on-a-machine-without-a-physical-ad)
        virtual_interface_name = "eth10"
        # assume that IP can be changed and that virtual interafce needs to be created if changing fails
        try:
            # since `ip addr change` doesn't work (or is a synonym for `ip addr add`(manpage is as unclear as possible)) delete old address first
            if self.virtual_interface_address != None:
                sp.check_call([ip, "addr", "del", self.virtual_interface_address, "dev", virtual_interface_name])
            sp.check_call([ip, "addr", "change", self.external_ip, "dev", virtual_interface_name])
            self.virtual_interface_address = self.external_ip
            logger.info("changed IP of virtual interface %s to %s" % (virtual_interface_name, self.external_ip))
            for port, protocol in [(7000, "udp"), (7001, "udp"), (7002, "udp"), (7003, "udp"), (7004, "udp"), (7005, "udp"), (7006, "udp"), (7007, "udp"), (7008, "udp"), (7021, "udp")]:
                sp.check_call([iptables, "-A", "PREROUTING", "-t", "nat", "-i", "eth0", "-p", protocol, "--dport", str(port), "-j", "DNAT", "--to", "%s:%s" % (self.external_ip, port)])
            logger.info("added iptables port forwarding rules for virtual interface %s" % (virtual_interface_name,))
        except sp.CalledProcessError:
            sp.check_call([modprobe, "dummy"])
            sp.check_call([ip, "link", "set", "name", virtual_interface_name, "dev", "dummy0"])
            sp.check_call([ifconfig, virtual_interface_name, "hw", "ether", "00:22:22:ff:ff:ff"])
            sp.check_call([ip, "addr", "add", self.external_ip, "dev", virtual_interface_name])
            #sp.check_call([ip, "addr", "add", self.external_ip, "dev", virtual_interface_name, "label", "%s:0" % (virtual_interafce_name,)])
                # creating an alias shouldn't be necessary
            logger.info("created virutal interface %s with IP %s" % (virtual_interface_name, self.external_ip))
        # Adjust CellServDB
        client_cellservdb = "/etc/openafs/CellServDB"
        server_cellservdb = "/etc/openafs/server/CellServDB"
        from Cheetah.Template import Template
        t = Template(file="/etc/openafs/CellServDB.tmpl")
        t.external_ip = self.external_ip
        t_file = open(client_cellservdb, "w")
        t_file.write(str(t))
        t_file.flush()
        t_file.close()
        logger.info("updated client CellServDB file '%s'" % (client_cellservdb,))
        t = Template(file="/etc/openafs/server/CellServDB.tmpl")
        t.external_ip = self.external_ip
        t_file = open(server_cellservdb, "w")
        t_file.write(str(t))
        t_file.flush()
        t_file.close()
        logger.info("updated server CellServDB file '%s'" % (server_cellservdb,))
        # Restart OpenAFS fileserver
        systemd_unit = "openafs-fileserver.service"
        sp.check_call([systemctl, "restart", systemd_unit])
        logger.info("restarted systemd unit '%s'" % (systemd_unit,))

class StratoDDNSUpdater(DDNSUpdater):

    def __init__(self,
        hostname,
        username,
        password,
        no_mx,
        base_url,
        check_file_path,
        check_interval,
        daemon,
        loop,
        log_dir,
        debug,
        ip_service,
        dig_hostname
    ):
        super(StratoDDNSUpdater, self).__init__(check_file_path=check_file_path,
            check_interval=check_interval,
            daemon=daemon,
            loop=loop,
            log_dir=log_dir,
            debug=debug,
            ip_service=ip_service,
            dig_hostname=dig_hostname)
        self.name = "strato"
        self.hostname=hostname
        self.username=username
        self.password=password
        self.no_mx = no_mx
        self.base_url = base_url

    def action(self):
        \# Create an OpenerDirector with support for Basic HTTP Authentication...
        auth_handler = urllib2.HTTPBasicAuthHandler()
        auth_handler.add_password(realm='strato DDSN updater',
                                  uri=self.base_url,
                                  user=self.username,
                                  passwd=self.password)
        opener = urllib2.build_opener(auth_handler)
        \# ...and install it globally so it can be used with urlopen.
        urllib2.install_opener(opener)

        if self.no_mx is False:
            mx_str = "&mx=%s" % (self.hostname, )
        else:
            mx_str = ""

        request_url = "%s?hostname=%s%s&myip=%s&mxback=NO" % (self.base_url, self.hostname, mx_str, self.external_ip, )
        request = urllib2.Request(request_url)
        \# You need the replace to handle encodestring adding a trailing newline
        \# (https://docs.python.org/2/library/base64.html#base64.encodestring)
        base64string = base64.encodestring('%s:%s' % (self.username, self.password)).replace('\n', '')
        request.add_header("Authorization", "Basic %s" % base64string)
        logger.debug("making strato HTTP request to '%s'" % (request_url,))
        result = urllib2.urlopen(request).readline().strip()
        logger.info("strato update site returned response '%s'" % (result, ))
        if not result.startswith("good "):
            if result.startswith("badauth "):
                if self.loop:
                    logger.warn("response was 'badauth', sleeping for 10 minutes")
                else:
                    logger.warn("response was 'badauth', aborting")
                return 10*60 # wait 10 minutes after a badauth
            else:
                raise Exception("request failed because of unknown response (see above)")

\# necessary to allow setup of `setuptools` `entry_points`
def main():
    plac.Interpreter.call(DDNSUpdaterCommandParser)

if __name__ == "__main__":
    try:
        main()
    except:
        logger.exception("unexpected exception occured (see previous message for details)")
